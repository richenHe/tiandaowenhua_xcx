# 支付成功后业务逻辑详细文档

**版本**: V1.0
**创建时间**: 2026-02-14
**状态**: 待审核

---

## 📋 目录

1. [概述](#概述)
2. [前端处理流程](#前端处理流程)
3. [支付回调业务逻辑](#支付回调业务逻辑)
4. [订单类型处理详情](#订单类型处理详情)
5. [大使奖励机制](#大使奖励机制)
6. [数据库更新操作](#数据库更新操作)
7. [前端页面更新](#前端页面更新)
8. [异常处理](#异常处理)

---

## 概述

### 业务场景

支付成功后，系统需要根据不同的订单类型（`order_type`）执行相应的业务逻辑：

- **order_type=1**: 课程购买（初探班/密训班）
- **order_type=2**: 复训费支付
- **order_type=4**: 大使升级支付

### 执行模式

- **前端处理**: 支付成功后立即跳转到订单详情页，显示支付成功状态
- **后端异步处理**: 微信支付回调接口异步执行业务逻辑（发放课程、奖励计算、名额发放等）
- **用户体验**: 用户无需等待后端处理完成，可立即查看订单状态

---

## 前端处理流程

### 1. 支付接口调用

**文件位置**: `pages/order/payment/index.vue`

**当前代码** (第116-178行):

```javascript
const handlePay = async () => {
  try {
    uni.showLoading({ title: '支付中...' });

    // 1. 调用支付接口
    const payParams = await OrderApi.createPayment({
      order_no: orderInfo.value.orderNo
    });

    uni.hideLoading();

    // 2. 调用微信支付
    uni.requestPayment({
      timeStamp: payParams.timeStamp,
      nonceStr: payParams.nonceStr,
      package: payParams.package,
      signType: payParams.signType,
      paySign: payParams.paySign,
      success: () => {
        // 支付成功
        uni.showToast({
          title: '支付成功',
          icon: 'success',
          duration: 2000,
        });

        // 2秒后跳转到订单详情页
        setTimeout(() => {
          uni.redirectTo({
            url: '/pages/order/detail/index?orderNo=' + orderInfo.value.orderNo,
          });
        }, 2000);
      },
      fail: (err) => {
        // 支付失败处理
        if (err.errMsg && err.errMsg.includes('cancel')) {
          uni.showToast({
            title: '已取消支付',
            icon: 'none',
            duration: 1500
          });
          setTimeout(() => {
            uni.navigateBack();
          }, 1500);
        } else {
          uni.showToast({
            title: '支付失败',
            icon: 'none',
          });
        }
      }
    });
  } catch (error) {
    uni.hideLoading();
    console.error('发起支付失败:', error);
  }
};
```

### 2. 需要优化的前端逻辑

**建议修改**:

```javascript
success: () => {
  // 支付成功
  uni.showToast({
    title: '支付成功',
    icon: 'success',
    duration: 2000,
  });

  // ⚠️ 注意：后端业务逻辑（发放课程、奖励计算等）会异步执行
  // 前端无需等待，直接跳转到订单详情页
  setTimeout(() => {
    uni.redirectTo({
      url: '/pages/order/detail/index?orderNo=' + orderInfo.value.orderNo,
    });
  }, 2000);
}
```

---

## 支付回调业务逻辑

### 回调接口

**接口地址**: `POST /api/order/notify` (微信支付回调)
**云函数**: `callbacks` → `paymentCallback`
**触发时机**: 微信支付成功后，微信服务器主动调用

### 公共处理流程

```javascript
// 1. 验证微信签名（确保请求来自微信服务器）
const isValid = verifyWechatSignature(request);
if (!isValid) {
  return { code: 'FAIL', message: '签名验证失败' };
}

// 2. 解析支付结果
const { out_trade_no, transaction_id, payer } = request.body;

// 3. 查询订单信息
const order = await db.from('orders')
  .select('*')
  .eq('order_no', out_trade_no)
  .single();

// 4. 验证订单状态（防止重复处理）
if (order.pay_status === 1) {
  return { code: 'SUCCESS', message: '订单已处理' };
}

// 5. 更新订单状态
await db.from('orders').update({
  pay_status: 1,           // 已支付
  pay_time: new Date(),
  transaction_id: transaction_id,
  pay_method: '微信支付'
}).eq('order_no', out_trade_no);

// 6. 根据订单类型执行业务逻辑
switch (order.order_type) {
  case 1:
    await handleCoursePurchase(order);
    break;
  case 2:
    await handleRetrainPayment(order);
    break;
  case 4:
    await handleAmbassadorUpgrade(order);
    break;
}

// 7. 返回成功响应给微信
return { code: 'SUCCESS', message: '处理成功' };
```

---

## 订单类型处理详情

### Type 1: 课程购买

**适用场景**: 购买初探班（1688元）或密训班（38888元）

#### 业务逻辑

```javascript
async function handleCoursePurchase(order) {
  // 1. 查询课程信息
  const course = await db.from('courses')
    .select('*, included_course_ids')
    .eq('id', order.related_id)
    .single();

  // 2. 插入主课程到 user_courses 表
  const userCourse = await db.from('user_courses').insert({
    user_id: order.user_id,
    user_uid: order.user_uid,
    course_id: course.id,
    course_type: course.type,          // 冗余存储课程类型
    course_name: course.name,          // 冗余存储课程名称
    order_no: order.order_no,          // 关联订单号
    buy_price: order.final_amount,     // 购买价格
    buy_time: new Date(),              // 购买时间
    is_gift: false,                    // 非赠送课程
    attend_count: 1,                   // 初始化为1（可首次上课）
    status: 1,                         // 有效
    created_at: new Date()
  }).select().single();

  // 3. 如果是密训班，赠送初探班
  if (course.included_course_ids && course.included_course_ids.length > 0) {
    for (const giftCourseId of course.included_course_ids) {
      // 检查用户是否已有该课程
      const existingCourse = await db.from('user_courses')
        .select('id')
        .eq('user_id', order.user_id)
        .eq('course_id', giftCourseId)
        .single();

      if (!existingCourse) {
        // 查询赠送课程信息
        const giftCourse = await db.from('courses')
          .select('name, type')
          .eq('id', giftCourseId)
          .single();

        // 插入赠送课程
        await db.from('user_courses').insert({
          user_id: order.user_id,
          user_uid: order.user_uid,
          course_id: giftCourseId,
          course_type: giftCourse.type,     // 课程类型
          course_name: giftCourse.name,     // 课程名称
          order_no: order.order_no,         // 关联订单号
          buy_price: 0,                     // 赠送课程价格为0
          buy_time: new Date(),
          is_gift: true,                    // 赠送课程
          gift_source: `购买${course.name}赠送`, // 赠送来源说明
          source_order_id: order.id,        // 来源订单ID
          source_course_id: course.id,      // 来源课程ID（密训班）
          attend_count: 1,
          status: 1,
          created_at: new Date()
        });
      }
    }
  }

  // 4. 首次购买：锁定推荐人
  const isFirstPurchase = await checkFirstPurchase(order.user_id);
  if (isFirstPurchase) {
    await db.from('users').update({
      referee_confirmed_at: new Date()
    }).eq('id', order.user_id);
  }

  // 5. 计算并发放推荐人奖励
  await calculateAndGrantReward(order);

  // 6. 发送购买成功通知
  await sendPurchaseNotification(order.user_id, course.name);
}
```

#### 关键点

1. **attend_count 初始化为 1**: 用户购买后即可预约首次上课，无需额外操作
2. **密训班赠送初探班**: 自动检查并赠送，避免重复
3. **奖励计算**: 只按订单金额计算（密训班38888元），不重复计算赠送课程（1688元）

---

### Type 2: 复训费支付

**适用场景**: 用户第二次及以后预约上课需支付复训费（500元）

#### 业务逻辑

```javascript
async function handleRetrainPayment(order) {
  // 1. 查询用户课程信息
  const userCourse = await db.from('user_courses')
    .select('course_id, course_name')
    .eq('id', order.related_id)
    .single();

  // 2. 查询用户信息
  const user = await db.from('users')
    .select('real_name, phone')
    .eq('id', order.user_id)
    .single();

  // 3. 创建预约记录
  await db.from('appointments').insert({
    user_id: order.user_id,
    user_uid: order.user_uid,
    user_name: user.real_name,         // 冗余用户姓名
    user_phone: user.phone,            // 冗余用户手机号
    class_record_id: order.class_record_id,
    user_course_id: order.related_id,
    course_id: userCourse.course_id,   // 冗余课程ID
    course_name: userCourse.course_name, // 冗余课程名称
    is_retrain: true,                  // 标记为复训
    order_no: order.order_no,          // 关联订单号
    status: 0,                         // 待上课
    created_at: new Date()
  });

  // 4. 更新课程记录已预约人数
  await db.from('class_records')
    .update({ booked_quota: db.raw('booked_quota + 1') })
    .eq('id', order.class_record_id);

  // 5. 不发放推荐人奖励（复训费不计入奖励）

  // 6. 发送预约成功通知
  await sendAppointmentNotification(order.user_id, order.class_record_id);
}
```

#### 关键点

1. **不发放推荐人奖励**: 复训费不计入推荐人奖励体系
2. **自动创建预约**: 支付成功后自动完成预约，无需用户再次操作

---

### Type 4: 大使升级支付

**适用场景**: 青鸾大使升级为鸿鹄大使（9800元）

#### 业务逻辑

```javascript
async function handleAmbassadorUpgrade(order) {
  const targetLevel = order.related_id; // 目标等级

  // 1. 查询目标等级配置
  const config = await db.from('ambassador_level_configs')
    .select('*')
    .eq('level', targetLevel)
    .single();

  // 2. 更新用户等级
  await db.from('users').update({
    ambassador_level: targetLevel,
    ambassador_start_date: new Date()
  }).eq('id', order.user_id);

  // 3. 发放初探班名额（如果配置了 gift_quota_basic > 0）
  if (config.gift_quota_basic > 0) {
    await db.from('ambassador_quotas').insert({
      user_id: order.user_id,
      user_uid: order.user_uid,
      ambassador_level: targetLevel,
      quota_type: 1,                        // 初探班
      source_type: 1,                       // 大使升级
      source_remark: `升级为${config.level_name}`,
      total_quantity: config.gift_quota_basic,
      used_quantity: 0,
      remaining_quantity: config.gift_quota_basic,
      expire_date: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000), // 1年后过期
      status: 1,
      created_at: new Date()
    });
  }

  // 4. 发放密训班名额（如果配置了 gift_quota_advanced > 0）
  if (config.gift_quota_advanced > 0) {
    await db.from('ambassador_quotas').insert({
      user_id: order.user_id,
      user_uid: order.user_uid,
      ambassador_level: targetLevel,
      quota_type: 2,                        // 密训班
      source_type: 1,                       // 大使升级
      source_remark: `升级为${config.level_name}`,
      total_quantity: config.gift_quota_advanced,
      used_quantity: 0,
      remaining_quantity: config.gift_quota_advanced,
      expire_date: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000),
      status: 1,
      created_at: new Date()
    });
  }

  // 5. 发放冻结积分（如果配置了 frozen_points > 0）
  if (config.frozen_points > 0) {
    await db.from('users')
      .update({ cash_points_frozen: db.raw(`cash_points_frozen + ${config.frozen_points}`) })
      .eq('id', order.user_id);

    // 插入积分明细
    await db.from('cash_points_records').insert({
      user_id: order.user_id,
      user_uid: order.user_uid,
      type: 1,                              // 获得冻结
      amount: config.frozen_points,
      order_no: order.order_no,
      remark: `升级为${config.level_name}，发放冻结积分`,
      created_at: new Date()
    });
  }

  // 6. 发送升级成功通知
  await sendUpgradeNotification(order.user_id, config.level_name);
}
```

#### 关键点

1. **所有数值从配置表读取**: 不硬编码金额、积分、名额数量
2. **名额有效期**: 默认1年，可根据业务需求调整
3. **冻结积分**: 升级时发放，推荐学员首次上课时解冻

---

## 大使奖励机制

### 奖励计算规则

**配置来源**: `ambassador_level_configs` 表

| 大使等级 | 推荐初探班功德分 | 推荐密训班功德分 | 推荐初探班积分 | 推荐密训班积分 |
|---------|----------------|----------------|--------------|--------------|
| 准青鸾(1) | 0% | 0% | 0% | 0% |
| 青鸾(2) | 30% | 20% | 30% | 20% |
| 鸿鹄(3) | 30% | 20% | 30% | 20% |

**注意**: 以上比例为示例数据，实际比例从 `ambassador_level_configs` 表的以下字段读取：
- `merit_rate_basic`: 推荐初探班功德分比例
- `merit_rate_advanced`: 推荐密训班功德分比例
- `cash_rate_basic`: 推荐初探班可提现积分比例
- `cash_rate_advanced`: 推荐密训班可提现积分比例

### 奖励发放逻辑

```javascript
async function calculateAndGrantReward(order) {
  // 1. 查询推荐人信息
  const referee = await db.from('users')
    .select('id, uid, ambassador_level, real_name')
    .eq('id', order.referee_id)
    .single();

  if (!referee) {
    console.log('无推荐人，跳过奖励发放');
    return;
  }

  // 2. 查询推荐人等级配置
  const config = await db.from('ambassador_level_configs')
    .select('*')
    .eq('level', referee.ambassador_level)
    .single();

  // 3. 检查是否可获得奖励
  if (!config.can_earn_reward) {
    console.log('推荐人等级不可获得奖励');
    return;
  }

  // 4. 查询课程类型
  const course = await db.from('courses')
    .select('type')
    .eq('id', order.related_id)
    .single();

  // 5. 计算奖励金额
  const baseAmount = order.final_amount; // 订单金额
  let meritPoints = 0;
  let cashPoints = 0;

  if (course.type === 1) {
    // 初探班
    meritPoints = baseAmount * config.merit_rate_basic;
    cashPoints = baseAmount * config.cash_rate_basic;
  } else if (course.type === 2) {
    // 密训班
    meritPoints = baseAmount * config.merit_rate_advanced;
    cashPoints = baseAmount * config.cash_rate_advanced;
  }

  // 6. 发放功德分
  if (meritPoints > 0) {
    await db.from('users')
      .update({ merit_points: db.raw(`merit_points + ${meritPoints}`) })
      .eq('id', referee.id);

    // 查询被推荐人姓名
    const refereeUser = await db.from('users')
      .select('real_name')
      .eq('id', order.user_id)
      .single();

    // 插入功德分明细
    await db.from('merit_points_records').insert({
      user_id: referee.id,
      user_uid: referee.uid,
      type: 1,                            // 获得
      source: course.type === 1 ? 1 : 2,  // 1推荐初探班/2推荐密训班
      amount: meritPoints,
      order_no: order.order_no,
      referee_user_id: order.user_id,
      referee_user_name: refereeUser.real_name,
      remark: `推荐学员购买${course.name}`,
      created_at: new Date()
    });
  }

  // 7. 发放冻结积分（所有等级统一发放到冻结余额）
  if (cashPoints > 0) {
    // 查询被推荐人姓名
    const refereeUser = await db.from('users')
      .select('real_name')
      .eq('id', order.user_id)
      .single();

    // 所有等级统一发放冻结积分
    await db.from('users')
      .update({ cash_points_frozen: db.raw(`cash_points_frozen + ${cashPoints}`) })
      .eq('id', referee.id);

    await db.from('cash_points_records').insert({
      user_id: referee.id,
      user_uid: referee.uid,
      type: 1,                          // 获得冻结
      amount: cashPoints,
      order_no: order.order_no,
      referee_user_id: order.user_id,
      referee_user_name: refereeUser.real_name,
      remark: `推荐学员购买${course.name}，发放冻结积分`,
      created_at: new Date()
    });
  }

  // 8. 更新订单奖励发放状态
  await db.from('orders').update({
    is_reward_granted: true,
    reward_granted_at: new Date()
  }).eq('order_no', order.order_no);

  console.log(`奖励发放成功: 功德分=${meritPoints}, 积分=${cashPoints}`);
}
```

### 积分解冻机制

**触发时机**: 推荐的学员首次上课签到时

**解冻逻辑** (在签到接口中执行):

```javascript
// 签到时解冻推荐人积分
async function unfreezeRefereePoints(userId, orderId) {
  // 1. 查询推荐人
  const user = await db.from('users')
    .select('referee_id')
    .eq('id', userId)
    .single();

  if (!user.referee_id) return;

  // 2. 查询推荐人等级配置
  const referee = await db.from('users')
    .select('uid, ambassador_level, cash_points_frozen')
    .eq('id', user.referee_id)
    .single();

  const config = await db.from('ambassador_level_configs')
    .select('unfreeze_per_referral')
    .eq('level', referee.ambassador_level)
    .single();

  const unfreezeAmount = config.unfreeze_per_referral;

  // 3. 解冻积分
  if (unfreezeAmount > 0 && referee.cash_points_frozen >= unfreezeAmount) {
    await db.from('users').update({
      cash_points_frozen: db.raw(`cash_points_frozen - ${unfreezeAmount}`),
      cash_points_available: db.raw(`cash_points_available + ${unfreezeAmount}`)
    }).eq('id', user.referee_id);

    // 查询被推荐人姓名
    const refereeUser = await db.from('users')
      .select('real_name')
      .eq('id', userId)
      .single();

    // 插入积分明细
    await db.from('cash_points_records').insert({
      user_id: user.referee_id,
      user_uid: referee.uid,
      type: 2,                            // 解冻
      amount: unfreezeAmount,
      order_no: orderId,
      referee_user_id: userId,
      referee_user_name: refereeUser.real_name,
      remark: '推荐学员首次上课，解冻积分',
      created_at: new Date()
    });

    // 青鸾大使首次推荐标记
    if (referee.ambassador_level === 2) {
      await db.from('users')
        .update({ is_first_recommend: true })
        .eq('id', user.referee_id);
    }
  }
}
```

---

## 数据库更新操作

### 涉及的数据表

| 表名 | 操作 | 说明 |
|-----|------|------|
| `orders` | UPDATE | 更新支付状态、支付时间、交易号 |
| `user_courses` | INSERT | 添加用户课程记录（主课程+赠送课程） |
| `appointments` | INSERT | 创建预约记录（复训专用） |
| `users` | UPDATE | 更新大使等级、功德分、积分 |
| `ambassador_quotas` | INSERT | 发放大使名额 |
| `merit_points_records` | INSERT | 功德分明细记录 |
| `cash_points_records` | INSERT | 积分明细记录 |

### 事务处理

**重要**: 所有数据库操作必须在事务中执行，确保数据一致性

```javascript
const { data, error } = await db.transaction(async (trx) => {
  // 1. 更新订单状态
  await trx.from('orders').update({ pay_status: 1 });

  // 2. 插入用户课程
  await trx.from('user_courses').insert({ ... });

  // 3. 发放奖励
  await trx.from('users').update({ merit_points: ... });

  // 4. 插入明细记录
  await trx.from('merit_points_records').insert({ ... });

  return { success: true };
});

if (error) {
  console.error('事务执行失败，已回滚:', error);
  throw error;
}
```

---

## 前端页面更新

### 1. 我的订单页面

**文件位置**: `pages/mine/orders/index.vue`

**需要更新的内容**:

- 订单状态从"待支付"变为"已完成"
- 显示支付时间
- 显示交易号

**建议实现**:

```javascript
// 订单列表接口会返回最新状态
const loadOrders = async () => {
  const orders = await OrderApi.getList({
    status: 1,  // 已支付
    page: 1,
    page_size: 10
  });

  orderList.value = orders.list.map(order => ({
    ...order,
    statusText: getStatusText(order.pay_status),
    statusColor: getStatusColor(order.pay_status)
  }));
};

function getStatusText(payStatus) {
  const statusMap = {
    0: '待支付',
    1: '已完成',
    2: '已取消',
    3: '已关闭',
    4: '已退款'
  };
  return statusMap[payStatus] || '未知';
}
```

### 2. 我的课程页面

**文件位置**: `pages/course/my-courses/index.vue`

**需要更新的内容**:

- 新增已购买的课程
- 显示课程购买时间
- 显示是否为赠送课程

**建议实现**:

```javascript
const loadMyCourses = async () => {
  const courses = await CourseApi.getMyCourses();

  courseList.value = courses.list.map(course => ({
    ...course,
    giftTag: course.is_gift ? '赠送' : '',
    canRetrain: course.attend_count > 1,
    statusText: course.status === 1 ? '有效' : '已失效'
  }));
};
```

### 3. 大使中心页面

**文件位置**: `pages/ambassador/index.vue`

**需要更新的内容**:

- 功德分余额更新
- 积分余额更新（冻结/可用）
- 推荐学员列表更新
- 名额数量更新（大使升级后）

**建议实现**:

```javascript
const loadAmbassadorInfo = async () => {
  const info = await AmbassadorApi.getInfo();

  ambassadorInfo.value = {
    level: info.level,
    levelName: info.level_name,
    meritPoints: info.merit_points,
    cashPointsFrozen: info.cash_points_frozen,
    cashPointsAvailable: info.cash_points_available,
    totalReferees: info.total_referees
  };

  // 加载名额信息（如果是鸿鹄及以上）
  if (info.level >= 3) {
    const quotas = await AmbassadorApi.getMyQuotas();
    quotaList.value = quotas.list;
  }
};
```

---

## 异常处理

### 1. 支付回调重复处理

**问题**: 微信可能多次发送支付回调

**解决方案**:

```javascript
// 检查订单状态，避免重复处理
if (order.pay_status === 1) {
  console.log('订单已处理，跳过');
  return { code: 'SUCCESS', message: '订单已处理' };
}
```

### 2. 事务失败回滚

**问题**: 数据库操作失败导致数据不一致

**解决方案**:

```javascript
try {
  await db.transaction(async (trx) => {
    // 所有数据库操作
  });
} catch (error) {
  console.error('事务失败，已自动回滚:', error);
  // 记录错误日志
  await logError({
    type: 'payment_callback_error',
    order_no: order.order_no,
    error: error.message
  });
  throw error;
}
```

### 3. 推荐人不存在

**问题**: 订单中的推荐人ID无效

**解决方案**:

```javascript
const referee = await db.from('users')
  .select('*')
  .eq('id', order.referee_id)
  .single();

if (!referee) {
  console.log('推荐人不存在，跳过奖励发放');
  // 更新订单标记
  await db.from('orders').update({
    is_reward_granted: false,
    reward_granted_at: null,
    remark: '推荐人不存在'
  }).eq('order_no', order.order_no);
  return;
}
```

### 4. 配置数据缺失

**问题**: `ambassador_level_configs` 表中缺少等级配置

**解决方案**:

```javascript
const config = await db.from('ambassador_level_configs')
  .select('*')
  .eq('level', referee.ambassador_level)
  .single();

if (!config) {
  console.error('等级配置不存在:', referee.ambassador_level);
  // 使用默认配置或跳过
  return;
}
```

---

## 总结

### 关键要点

1. **前端立即返回**: 支付成功后立即跳转，无需等待后端处理
2. **后端异步处理**: 微信回调接口异步执行业务逻辑
3. **事务保证一致性**: 所有数据库操作在事务中执行
4. **配置驱动**: 所有金额、比例、数量从配置表读取
5. **幂等性保证**: 防止重复处理支付回调
6. **字段对齐**: 所有字段名称与数据库表结构完全一致

### 待实现功能

- [ ] 支付回调接口 (`callbacks` 云函数)
- [ ] 课程购买处理逻辑
- [ ] 复训费处理逻辑
- [ ] 大使升级处理逻辑
- [ ] 奖励计算和发放
- [ ] 积分解冻机制（签到时触发）
- [ ] 前端页面状态更新

### 注意事项

1. **微信商户配置**: 需要配置微信商户号、API密钥、证书等
2. **回调地址**: 确保回调地址可被微信服务器访问
3. **日志记录**: 记录所有关键操作日志，便于排查问题
4. **错误通知**: 异常情况及时通知管理员

---

**文档结束**
