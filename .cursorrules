# 项目开发规范

## 字段命名规范 ⚠️

**固定命名规则，全项目统一遵循：**

### 1. 前端与云函数交互
- **URL 参数**：使用 **camelCase（驼峰命名）**
- **前端 API 参数**：使用 **camelCase（驼峰命名）**
- **云函数接收参数**：使用 **camelCase（驼峰命名）**

```typescript
// ✅ 正确 - URL 参数使用驼峰命名
uni.navigateTo({
  url: `/pages/order/confirm/index?courseId=${courseId}`
})

// ✅ 正确 - 前端 API 参数使用驼峰命名
await UserApi.updateProfile({
  realName: '张三',
  phone: '13800138000',
  city: '北京',
  avatar: 'https://...',
  gender: '男',
  industry: '互联网',
  birthday: '1990-01-01'
})

// ❌ 错误 - 不要使用下划线命名
{
  real_name: '张三',  // 这会导致"缺少必填参数"错误
  course_id: 1        // URL 参数也不能用下划线
}
```

### 2. 数据库字段
使用 **snake_case（下划线命名）**：
- `real_name`, `phone`, `city`, `avatar`, `gender`, `industry`, `birth_bazi`
- `created_at`, `updated_at`, `profile_completed`
- `ambassador_level`, `merit_points`, `cash_points_available`

### 3. 云函数内部转换
云函数接收驼峰参数，存入数据库时转换为下划线：

```javascript
// ✅ 正确 - 云函数参数处理
module.exports = async (event, context) => {
  const { realName, phone, city, avatar } = event;  // 接收驼峰命名
  
  // 存入数据库时转换为下划线
  const updateData = {
    real_name: realName,  // 转换为 snake_case
    phone: phone,
    city: city || '',
    avatar: avatar || ''
  };
};
```

### 4. 云函数返回数据
使用 **snake_case（下划线命名）**，与数据库保持一致：

```javascript
// 云函数返回数据库原始字段
return response.success({
  real_name: user.real_name,
  phone: user.phone,
  profile_completed: 1
})
```

### 5. 命名对照表

| 数据库字段 | 云函数接收参数 | 前端API参数 | URL参数 | 说明 |
|-----------|--------------|-----------|---------|------|
| real_name | realName | realName | realName | 真实姓名 |
| phone | phone | phone | phone | 手机号 |
| city | city | city | city | 城市 |
| avatar | avatar | avatar | avatar | 头像 |
| gender | gender | gender | gender | 性别 |
| industry | industry | industry | industry | 行业 |
| birth_bazi | birthday | birthday | birthday | 出生八字 |
| course_id | courseId | courseId | courseId | 课程ID |
| class_record_id | classRecordId | classRecordId | classRecordId | 排期ID |
| order_type | orderType | orderType | orderType | 订单类型 |
| item_id | itemId | itemId | itemId | 商品ID |

### 6. 核心原则总结 ⚠️

1. **前端 → 云函数**：始终使用 **camelCase（驼峰命名）**
2. **URL 参数**：始终使用 **camelCase（驼峰命名）**
3. **云函数 → 数据库**：云函数内部转换为 **snake_case（下划线命名）**
4. **数据库字段**：始终使用 **snake_case（下划线命名）**
5. **云函数 → 前端**：返回数据库原始字段（snake_case）

**关键教训**：
- ✅ 前端调用 API 时使用 `realName`（驼峰）
- ✅ URL 参数使用 `courseId`（驼峰）
- ❌ 前端使用 `real_name`（下划线）会导致"缺少必填参数"错误
- ❌ URL 参数使用 `course_id`（下划线）会导致参数接收失败
- ✅ 云函数接收 `realName`（驼峰），内部转换为 `real_name`（下划线）存数据库

---

## 架构设计原则

### 统一页面原则
相似功能整合到统一页面，通过参数区分类型：
- 前端：同类功能用同一页面，根据参数动态渲染
- 后端：统一接口，通过 type 字段区分业务类型
- 数据库：使用 type/category/status 标识分类

示例：
- 订单支付页 (`pages/order/payment/index`)：课程订单/复训订单/升级订单共用
- 课程详情页 (`pages/course/detail/index`)：初探班/密训班/咨询服务共用
- 大使升级 (`pages/ambassador/contract-sign/index`)：青鸾/鸿鹄升级共用

## 前端开发规范

### 强制规范

#### 1. 样式规范（严格遵守）
- **禁止**：TDesign Vue 组件、自定义类名、硬编码颜色
- **必须**：使用 TDesign CSS 类名（.t-card/.t-button 等）
- **严格遵循样式优先级**：
  1. 优先使用 TDesign CSS 类名（先查 `src/styles/components/index.scss`）
  2. 如样式可复用且无类似组件，必须添加到 `src/styles/components/*.scss`
  3. 最后才考虑 inline style（仅用于真正的个性化场景）
  4. **绝对禁止**：自定义类名、随意的 style 标签样式
- **可复用性原则**：
  - 发现 2+ 处相同/类似样式 → 立即抽取到 components/*.scss
  - 新建 SCSS 文件时必须在 `components/index.scss` 中导入
  - 保持样式统一性，避免"一次性"样式
- **颜色规范**：只能使用 SCSS 变量（如 `$td-brand-color`）
- **修改前必查**：检查 `src/styles/components/` 是否有可用样式

#### 2. 盒模型规范（防止溢出）
- scroll-view 带 padding 必须设置 `boxSizing: 'border-box'`
- 带 padding 的容器外层加 `overflow: 'hidden'`
- 优先使用 .t-card（已处理盒模型）

正确示例：
```vue
<view :style="{ overflow: 'hidden' }">
  <scroll-view :style="{ padding: '24rpx', boxSizing: 'border-box' }">
    内容
  </scroll-view>
</view>
```

错误示例：
```vue
<!-- 会溢出 48rpx -->
<scroll-view :style="{ padding: '24rpx' }">内容</scroll-view>
```

#### 3. 弹窗规范
必须使用 `uni.showModal`，禁止自定义弹窗

#### 4. 其他规范
- 可滚动页面底部留白 120rpx
- 禁止自动启动开发服务器（已运行）
- 原型图迁移：`var(--td-xxx)` → `$td-xxx`，`px` → `rpx`（1px=2rpx）

### 常用组件
基础：.t-card, .t-button, .t-badge, .t-avatar
表单：.t-form, .t-input, .t-radio-group
布局：.t-page-header, .t-section-title, .t-tabs
数据：.t-list, .t-cell

#### CapsuleTabs 吸顶组件
使用 CapsuleTabs 时必须配合 StickyTabs 实现吸顶：

```vue
<template>
  <scroll-view @scroll="handleScroll">
    <StickyTabs ref="stickyTabsRef" :offset-top="pageHeaderHeight">
      <template #tabs>
        <CapsuleTabs v-model="activeTab" :options="tabOptions" />
      </template>
    </StickyTabs>
  </scroll-view>
</template>

<script setup>
import CapsuleTabs from '@/components/CapsuleTabs.vue'
import StickyTabs from '@/components/StickyTabs.vue'

const stickyTabsRef = ref()
const pageHeaderHeight = ref(64)

onMounted(() => {
  const systemInfo = uni.getSystemInfoSync()
  pageHeaderHeight.value = (systemInfo.statusBarHeight || 20) + 44
})

const handleScroll = (e) => {
  stickyTabsRef.value?.updateScrollTop(e.detail.scrollTop)
}
</script>
```

**注意**：首页等有 Banner 的页面不需要吸顶，直接使用 CapsuleTabs。

### Code Review 检查清单
- [ ] **样式优先级**：先用 TDesign CSS 类名，再考虑可复用组件样式
- [ ] **可复用性**：相同样式已抽取到 components/*.scss
- [ ] **禁止项**：无自定义类名、无硬编码颜色、无随意 inline style
- [ ] **盒模型**：scroll-view 带 padding 设置了 boxSizing: border-box
- [ ] **溢出控制**：滚动容器外层有 overflow: hidden
- [ ] **布局一致性**：页面左右对称无溢出
- [ ] **交互规范**：弹窗用 uni.showModal
- [ ] **颜色规范**：所有颜色用 SCSS 变量（$td-xxx）
- [ ] **新增样式**：已确认 components/*.scss 中无类似样式，或已添加

### 样式优先级（强制执行）
**严格按照以下顺序，不得跳级：**

1. **TDesign CSS 类名**（第一选择）
   - 先查 `src/styles/components/index.scss` 及其引入的所有 SCSS 文件
   - 使用现有的 `.t-*` 类名，如 `.t-card`、`.t-button`、`.t-page-header__back-icon`
   - 如需调整，通过 CSS 变量或 SCSS 变量配置

2. **可复用组件样式**（第二选择）
   - 当前项目中 2+ 处需要相同样式 → 抽取到 `components/*.scss`
   - 命名规范：`.t-自定义名称`（如 `.t-price-card`、`.t-user-avatar`）
   - 新建文件后必须在 `components/index.scss` 中添加 `@import`
   - 必须使用 SCSS 变量，保持全局统一

3. **inline style**（第三选择，最后手段）
   - 仅用于真正的"一次性"个性化样式
   - 示例：特定渐变背景、单独的尺寸调整
   - 颜色仍需使用 SCSS 变量引用

4. **绝对禁止**
   - ❌ 自定义 class 类名
   - ❌ 硬编码颜色值（如 `#0052D9`、`rgba(0, 0, 0, 0.5)`）
   - ❌ `<style>` 标签中的临时样式
   - ❌ 不可复用的重复样式

### 样式添加流程
1. 需要样式 → 先查 `src/styles/components/`
2. 找到匹配 → 直接使用 TDesign 类名
3. 未找到 + 可复用 → 添加到 `components/*.scss` + 更新 `index.scss`
4. 未找到 + 一次性 → 使用 inline style（颜色仍用变量）
5. 完成后更新本规范文档

## 云函数开发规范

### 强制规范

#### 1. 运行时版本匹配（严格遵守）⚠️
- **创建云函数前必须检查依赖层支持的运行时版本**
- **禁止使用不兼容的运行时版本**
- 当前项目层配置：
  - common-layer：支持 `Nodejs14.18`
  - business-logic-layer：支持 `Nodejs14.18`
  - **必须使用 `Nodejs14.18` 创建云函数**

错误示例：
```javascript
// ❌ 错误 - 使用了不兼容的运行时
{
  "name": "user",
  "runtime": "Nodejs18.15"  // 层不支持此版本
}
```

正确示例：
```javascript
// ✅ 正确 - 使用层支持的运行时
{
  "name": "user",
  "runtime": "Nodejs14.18"  // 与层兼容
}
```

**教训**：运行时不匹配会导致部署失败，浪费时间反复删除重建！

#### 2. 目录结构规范
```
cloudfunctions/
├── 云函数名/
│   ├── index.js              # 入口文件（路由分发）
│   ├── package.json          # 依赖配置
│   ├── cloudfunction.json    # 云函数配置
│   └── handlers/             # 处理器目录
│       ├── client/           # 客户端接口
│       └── admin/            # 管理端接口
├── layers/                   # 层目录
│   ├── common/               # 公共层
│   └── business-logic/       # 业务逻辑层
└── cloudbaserc.json          # CloudBase 配置
```

#### 3. 路由架构规范
- 统一入口文件 `index.js` 处理路由分发
- 按 `action` 参数区分不同接口
- 客户端/管理端接口分离
- 统一错误处理和响应格式

标准入口模板：
```javascript
const cloud = require('wx-server-sdk');
const { response, checkClientAuth, checkAdminAuth } = require('common');

cloud.init({ env: cloud.DYNAMIC_CURRENT_ENV });

// 导入处理器
const clientHandlers = {
  action1: require('./handlers/client/action1'),
  action2: require('./handlers/client/action2')
};

const adminHandlers = {
  adminAction1: require('./handlers/admin/adminAction1')
};

// 路由配置
const ROUTES = {
  client: Object.keys(clientHandlers),
  admin: Object.keys(adminHandlers)
};

exports.main = async (event, context) => {
  const { action } = event;
  const OPENID = cloud.getWXContext().OPENID;

  try {
    // 客户端接口（需用户鉴权）
    if (ROUTES.client.includes(action)) {
      const user = await checkClientAuth(OPENID);
      return await clientHandlers[action](event, { OPENID, user });
    }

    // 管理端接口（需管理员鉴权）
    if (ROUTES.admin.includes(action)) {
      const admin = await checkAdminAuth(OPENID);
      return await adminHandlers[action](event, { OPENID, admin });
    }

    return response.paramError(`未知的操作: ${action}`);
  } catch (error) {
    console.error(`[${action}] 执行失败:`, error);
    return response.error(error.message, error, error.code || 500);
  }
};
```

#### 4. 权限验证规范
- 客户端接口：使用 `checkClientAuth(OPENID)` 验证用户身份
- 管理端接口：使用 `checkAdminAuth(OPENID)` 验证管理员权限
- 登录接口特殊处理：无需提前验证

```javascript
// 客户端接口处理器示例
const { query, response } = require('common');

module.exports = async (event, context) => {
  const { OPENID, user } = context;  // user 已通过鉴权
  
  try {
    // 业务逻辑
    const data = await query('SELECT * FROM table WHERE user_id = ?', [user.id]);
    return response.success(data, '查询成功');
  } catch (error) {
    return response.error('查询失败', error);
  }
};
```

#### 5. 响应格式规范
- 必须使用 common 层的 `response` 工具
- 统一响应格式：`{ success, code, message, data }`

```javascript
const { response } = require('common');

// 成功响应
return response.success(data, '操作成功');
// { success: true, code: 0, message: '操作成功', data: {...} }

// 错误响应
return response.error('操作失败', error);
// { success: false, code: 500, message: '操作失败', error: {...} }

// 参数错误
return response.paramError('缺少必要参数');
// { success: false, code: 400, message: '缺少必要参数' }

// 未授权
return response.unauthorized('用户未登录');
// { success: false, code: 401, message: '用户未登录' }
```

#### 6. 数据库操作规范
- **必须使用 common 层的数据库工具**
- **禁止直接创建数据库连接**
- **⚠️ 统一使用 Query Builder（强制执行）**：
  - **禁止使用原生 SQL**（`rawQuery`、`query` 等方法）
  - **必须使用 CloudBase Query Builder**（Supabase-style）
  - **所有查询（包括 JOIN）统一使用 `db.from()` 链式调用**
  - **理由**：
    1. ✅ 自动防止 SQL 注入
    2. ✅ 代码简洁、易读、易维护
    3. ✅ 统一项目风格，避免混乱
    4. ✅ 类型安全，减少错误
- **⚠️ 数据库名称规范**：
  - **业务数据库**：`tiandao_culture`（存放所有业务表）
  - **环境数据库**：`cloud1-0gnn3mn17b581124`（仅为环境ID，非业务数据库）
  - **强制要求**：所有 MCP 数据库查询操作必须明确指定 `tiandao_culture` 数据库
  - **SQL 语法**：`SELECT * FROM tiandao_culture.表名` 或 `SHOW TABLES FROM tiandao_culture`
- **⚠️ Query Builder JOIN 查询规范**：
  - **强制要求**：所有关联查询必须使用 Query Builder 的外键语法
  - **外键命名规范**：数据库中的外键格式为 `fk_表名_字段名`（如 `fk_orders_referee`）
  - **JOIN 语法**：`.select('*, 关联表别名:关联表名!外键名称(字段1, 字段2)')`
  - **正确示例**：
    ```javascript
    // ✅ 正确 - 使用 Query Builder + 外键名称进行 JOIN
    const { data, error } = await db
      .from('orders')
      .select(`
        *,
        referee:users!fk_orders_referee(id, real_name, nickname)
      `)
      .eq('user_id', userId)
      .order('created_at', { ascending: false })
      .range(0, 9);
    
    const { data: courses, error } = await db
      .from('user_courses')
      .select(`
        *,
        course:courses!fk_user_courses_course(id, name, type, price)
      `)
      .eq('user_id', userId);
    
    // ✅ 正确 - 多个 JOIN
    const { data: appointments, error } = await db
      .from('appointments')
      .select(`
        *,
        course:courses!fk_appointments_course(name, type),
        class_record:class_records!fk_appointments_class_record(class_date, start_time, end_time)
      `)
      .eq('user_id', userId)
      .is('deleted_at', null);
    ```
  - **错误示例**：
    ```javascript
    // ❌ 错误 - 使用了原生 SQL
    const result = await rawQuery(`
      SELECT a.*, c.name as course_name
      FROM appointments a
      LEFT JOIN courses c ON a.course_id = c.id
      WHERE a.user_id = ?
    `, [userId]);
    
    // ❌ 错误 - 使用了 Supabase 风格的自动推断外键名
    .select('*, referee:users(id, real_name)')  // 无外键名，会失败
    
    // ❌ 错误 - 使用了错误的外键命名格式
    .select('*, referee:users!orders_referee_id_fkey(id, real_name)')  // Postgres 风格，不适用
    ```
  - **查询外键名称**：使用以下 SQL 查看实际外键名称
    ```sql
    SELECT 
        TABLE_NAME,
        CONSTRAINT_NAME,
        COLUMN_NAME,
        REFERENCED_TABLE_NAME,
        REFERENCED_COLUMN_NAME
    FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE
    WHERE TABLE_SCHEMA = 'tiandao_culture'
    AND TABLE_NAME = '表名'
    AND REFERENCED_TABLE_NAME IS NOT NULL;
    ```

```javascript
const { db, response } = require('common');

// ✅ 正确 - 统一使用 Query Builder
// 简单查询
const { data: users, error } = await db
  .from('users')
  .select('*')
  .eq('id', userId);

// 带条件查询
const { data: orders, error } = await db
  .from('orders')
  .select('*')
  .eq('user_id', userId)
  .in('status', [1, 2, 3])
  .order('created_at', { ascending: false });

// JOIN 关联查询（推荐）
const { data: orders, error } = await db
  .from('orders')
  .select(`
    *,
    referee:users!fk_orders_referee(id, real_name)
  `)
  .eq('user_id', userId);

// ❌ 禁止使用原生 SQL
// 以下方法已废弃，不要使用：
// const result = await query('SELECT ...', [params]);
// const result = await rawQuery('SELECT ...');
```

**MCP 数据库查询示例**：
```sql
-- ✅ 正确 - 明确指定 tiandao_culture 数据库
SHOW TABLES FROM tiandao_culture;
SELECT * FROM tiandao_culture.users WHERE id = 1;
ALTER TABLE tiandao_culture.announcements ADD COLUMN _openid VARCHAR(64);

-- ❌ 错误 - 未指定数据库，可能查到环境数据库
SHOW TABLES;
SELECT * FROM users WHERE id = 1;

-- ❌ 错误 - 查询了环境数据库而非业务数据库
SELECT * FROM `cloud1-0gnn3mn17b581124`.users;
```

#### 7. 环境变量配置规范
在 `cloudbaserc.json` 中配置环境变量：
```json
{
  "functions": [
    {
      "name": "user",
      "runtime": "Nodejs14.18",
      "envVariables": {
        "MYSQL_HOST": "数据库主机",
        "MYSQL_PORT": "端口",
        "MYSQL_USER": "用户名",
        "MYSQL_PASSWORD": "密码",
        "MYSQL_DATABASE": "数据库名",
        "WECHAT_APPID": "小程序AppID",
        "WECHAT_APP_SECRET": "小程序密钥",
        "JWT_SECRET": "JWT密钥"
      },
      "layers": [
        {"name": "common", "version": 2},
        {"name": "business-logic", "version": 1}
      ]
    }
  ]
}
```

### Code Review 检查清单
- [ ] **运行时版本**：已确认使用 Nodejs14.18（与层兼容）
- [ ] **目录结构**：符合规范（index.js + handlers/client + handlers/admin）
- [ ] **路由架构**：统一入口，按 action 分发
- [ ] **权限验证**：客户端/管理端分离鉴权
- [ ] **响应格式**：使用 response 工具，格式统一
- [ ] **数据库操作**：使用 common 层工具，无直接连接
- [ ] **数据库名称**：MCP 查询已明确指定 `tiandao_culture` 数据库
- [ ] **Query Builder JOIN**：关联查询使用正确的外键名称（`fk_表名_字段名`格式）
- [ ] **环境变量**：敏感信息配置在环境变量中
- [ ] **错误处理**：统一 try-catch，记录日志
- [ ] **层依赖**：已正确引用 common 和 business-logic 层
- [ ] **_openid 字段**：所有表已添加 `_openid VARCHAR(64) DEFAULT '' NOT NULL` 字段

### 部署前检查清单
1. [ ] 检查依赖层支持的运行时版本
2. [ ] 确认 cloudbaserc.json 配置正确
3. [ ] 确认环境变量已配置完整
4. [ ] 确认 package.json 依赖正确
5. [ ] 本地测试通过
6. [ ] 使用正确的运行时版本创建/更新函数

### 常见错误及解决方案

#### 错误1：运行时版本不匹配
```
[UpdateFunctionConfiguration] 层版本xxx不适用当前运行时，请修正后重试。
```
**解决**：删除函数，使用 Nodejs14.18 重新创建

#### 错误2：层未找到
```
[CreateFunction] 未找到指定的Layer，请创建后再试。
```
**解决**：
1. 检查层名称格式：`层名_环境ID`
2. 使用 `tcb fn layer list` 查看实际层名称
3. 更新 cloudbaserc.json 中的层配置

#### 错误3：环境变量缺失
**解决**：在 CloudBase 控制台或 cloudbaserc.json 中补充环境变量

#### 错误4：查询了错误的数据库
```
查询结果为空或表不存在
```
**解决**：
1. 确认查询的是 `tiandao_culture` 数据库而非 `cloud1-0gnn3mn17b581124`
2. 在 SQL 中明确指定数据库名：`SELECT * FROM tiandao_culture.表名`
3. 使用 `SHOW TABLES FROM tiandao_culture` 查看所有业务表

#### 错误5：表缺少 _openid 字段
```
Error 1054: Unknown column '_openid' or 't0._openid' in 'where clause'
```
**解决**：
1. 使用 MCP 工具为表添加 `_openid` 字段：
   ```sql
   ALTER TABLE tiandao_culture.表名 ADD COLUMN _openid VARCHAR(64) DEFAULT '' NOT NULL COMMENT '用户openid' AFTER id;
   ```
2. 检查所有表是否都有 `_openid` 字段：
   ```sql
   SELECT TABLE_NAME, COLUMN_NAME 
   FROM INFORMATION_SCHEMA.COLUMNS 
   WHERE TABLE_SCHEMA = 'tiandao_culture' 
   AND COLUMN_NAME = '_openid'
   ORDER BY TABLE_NAME;
   ```

#### 错误6：Query Builder JOIN 查询失败
```
Error: failed to find relationship between orders and users
```
**解决**：
1. 检查是否使用了正确的外键名称（格式：`fk_表名_字段名`）
2. 查询实际外键名称：
   ```sql
   SELECT CONSTRAINT_NAME, COLUMN_NAME, REFERENCED_TABLE_NAME 
   FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE
   WHERE TABLE_SCHEMA = 'tiandao_culture'
   AND TABLE_NAME = '表名'
   AND REFERENCED_TABLE_NAME IS NOT NULL;
   ```
3. 修正 Query Builder 语法：
   ```javascript
   // ❌ 错误
   .select('*, referee:users(id, real_name)')
   
   // ✅ 正确
   .select('*, referee:users!fk_orders_referee(id, real_name)')
   ```

### 最佳实践
1. **一个云函数一个模块**：user/order/course/ambassador/system 分离
2. **复用 common 层**：数据库、工具、响应格式统一
3. **业务逻辑层**：复杂逻辑抽取到 business-logic 层
4. **接口命名规范**：动词+名词（getProfile/updateOrder/applyWithdraw）
5. **日志记录**：关键操作记录日志，便于排查问题
6. **参数验证**：使用 common 层的 validateRequired 验证必填参数
7. **数据库规范**：
   - 所有业务表统一存放在 `tiandao_culture` 数据库
   - MCP 查询必须明确指定数据库名：`tiandao_culture.表名`
   - 所有表必须包含 `_openid` 字段（CloudBase 权限控制必需）
   - 数据库连接配置在 `cloudfunctions/*/common/db.js` 中已正确设置
8. **关联查询规范**：
   - **统一使用 Query Builder**（禁止原生 SQL）
   - 必须明确指定外键名称（格式：`fk_表名_字段名`）
   - 所有外键信息参考 `docs/database/数据库详细信息.md` 文档
   - 示例：`db.from('orders').select('*, referee:users!fk_orders_referee(id, real_name)')`

---

## 公共代码同步部署规范 ⚠️

### 强制执行规则

**当修改以下公共代码目录时，必须同步更新所有云函数（除 callbacks）：**

1. **`cloudfunctions/common/`** - 公共工具层
   - 包含：`db.js`, `auth.js`, `response.js`, `utils.js`, `storage.js`
   - 影响：所有云函数的数据库操作、权限验证、响应格式等

2. **`cloudfunctions/business-logic/`** - 业务逻辑层
   - 包含：`payment.js`, `points.js`, `ambassador.js`, `notification.js`, `order.js` 等
   - 影响：所有云函数的业务逻辑处理

### 同步部署流程

#### 1. 识别需要更新的云函数

**当前项目云函数列表：**
- ✅ `user` - 用户模块
- ✅ `order` - 订单模块
- ✅ `course` - 课程模块
- ✅ `ambassador` - 大使模块
- ✅ `system` - 系统模块
- ❌ `callbacks` - 回调函数（**排除，不同步**）

#### 2. 自动同步命令（强制执行）

**每次修改 `common/` 或 `business-logic/` 后，必须执行以下操作：**

```bash
# 步骤1：同步公共代码到各云函数（手动复制或脚本）
# common/ 和 business-logic/ 已复制到各云函数目录中

# 步骤2：使用 MCP 工具批量更新云函数代码
# 注意：必须使用 updateFunctionCode，不要使用 updateFunctionConfig
```

#### 3. MCP 批量更新指令

**标准更新流程（按顺序执行）：**

1. **更新 user 云函数：**
   ```
   使用 mcp_cloudbase_updateFunctionCode 更新云函数：
   - name: user
   - functionRootPath: D:\project\cursor\work\xcx\cloudfunctions
   ```

2. **更新 order 云函数：**
   ```
   使用 mcp_cloudbase_updateFunctionCode 更新云函数：
   - name: order
   - functionRootPath: D:\project\cursor\work\xcx\cloudfunctions
   ```

3. **更新 course 云函数：**
   ```
   使用 mcp_cloudbase_updateFunctionCode 更新云函数：
   - name: course
   - functionRootPath: D:\project\cursor\work\xcx\cloudfunctions
   ```

4. **更新 ambassador 云函数：**
   ```
   使用 mcp_cloudbase_updateFunctionCode 更新云函数：
   - name: ambassador
   - functionRootPath: D:\project\cursor\work\xcx\cloudfunctions
   ```

5. **更新 system 云函数：**
   ```
   使用 mcp_cloudbase_updateFunctionCode 更新云函数：
   - name: system
   - functionRootPath: D:\project\cursor\work\xcx\cloudfunctions
   ```

#### 4. 同步检查清单

**修改公共代码后必须检查：**
- [ ] 已复制 `common/` 最新代码到所有云函数（除 callbacks）
- [ ] 已复制 `business-logic/` 最新代码到所有云函数（除 callbacks）
- [ ] 已使用 `updateFunctionCode` 更新所有云函数代码
- [ ] 未更新 `callbacks` 云函数（该函数独立维护）
- [ ] 更新完成后测试关键接口是否正常

### 注意事项 ⚠️

1. **updateFunctionCode vs updateFunctionConfig**：
   - ✅ `updateFunctionCode`：仅更新云函数代码，不修改配置（推荐）
   

2. **callbacks 云函数特殊说明**：
   - `callbacks` 云函数用于接收微信支付回调、消息推送等
   - 该云函数采用 HTTP 触发器，部署方式与其他云函数不同
   - **禁止同步更新 callbacks**，该云函数需独立维护

3. **functionRootPath 路径说明**：
   - Windows: `D:\project\cursor\work\xcx\cloudfunctions`
   - Linux/Mac: `/path/to/project/cloudfunctions`
   - 路径必须指向 `cloudfunctions` 目录（云函数的父目录）

4. **批量更新顺序**：
   - 建议按照：user → order → course → ambassador → system 的顺序更新
   - 如果某个云函数更新失败，不影响其他云函数继续更新

5. **更新失败处理**：
   - 检查云函数名称是否正确
   - 检查 functionRootPath 路径是否正确
   - 检查云函数目录结构是否完整（必须包含 index.js）
   - 如持续失败，尝试在 CloudBase 控制台手动上传

### 快速参考

**公共代码修改触发条件：**
- 修改 `cloudfunctions/common/` 下任何文件 → 触发同步
- 修改 `cloudfunctions/business-logic/` 下任何文件 → 触发同步

**同步目标云函数：**
- `user`, `order`, `course`, `ambassador`, `system`（5个）
- 排除：`callbacks`

**同步方式：**
- 工具：`mcp_cloudbase_updateFunctionCode`
- 参数：`name`（云函数名）, `functionRootPath`（云函数父目录）